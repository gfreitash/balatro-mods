name: Publish Mod to Index

on:
  workflow_dispatch:
    inputs:
      force_update:
        description: "Force update even if no changes detected"
        required: false
        type: boolean
        default: false
      tag_name: # Input for direct dispatch from Release Mod workflow
        description: "The full tag name (e.g., qol-bundle__v1.1.1) from Release Mod"
        required: true
        type: string

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      mods_json: ${{ steps.changes.outputs.mods_json }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # For push trigger diff

      - name: Detect changed mods and their titles from tag
        id: changes
        run: |
          echo "üîç Detecting changed mods and their titles..."
          mods_data_json="[]" # Initialize as empty JSON array

          RELEASE_TAG="${{ github.event.inputs.tag_name }}"
          echo "üéØ Triggered by workflow dispatch with tag: $RELEASE_TAG"
          if [[ "$RELEASE_TAG" =~ ^(.*)__v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            dir_name="${BASH_REMATCH[1]}"
            version="${BASH_REMATCH[2]}"
            echo "üì¶ Extracted mod directory: $dir_name and version: $version from tag: $RELEASE_TAG"
            meta_file_path="${dir_name}/index.meta.json"
            title_name="$dir_name" # Default to dir_name
            if [ -f "$meta_file_path" ]; then
              title_from_file=$(jq -r '.title' "$meta_file_path" 2>/dev/null)
              if [ -n "$title_from_file" ] && [ "$title_from_file" != "null" ]; then
                title_name="$title_from_file"
              else
                echo "‚ö†Ô∏è Could not read .title from $meta_file_path, using directory name '$dir_name' as title."
              fi
            else
              echo "‚ö†Ô∏è $meta_file_path not found, using directory name '$dir_name' as title."
            fi
            # IMPORTANT: Add 'tagName' to the JSON output to be used in subsequent steps
            mods_data_json=$(echo "$mods_data_json" | jq --arg dir "$dir_name" --arg title "$title_name" --arg ver "$version" --arg tag "$RELEASE_TAG" '. + [{dirName: $dir, titleName: $title, version: $ver, tagName: $tag}]')
          else
            echo "‚ÑπÔ∏è Dispatched tag '$RELEASE_TAG' did not match expected format (modDirName__vX.Y.Z). Skipping mod detection."
            exit 1 # Fail fast if tag format is wrong
          fi

          compact_mods_data_json=$(echo "$mods_data_json" | jq -c '.')
          {
            echo "mods_json<<EOF"
            echo "$compact_mods_data_json"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "‚úÖ Detection complete. Output for GITHUB_OUTPUT: $compact_mods_data_json"
          echo "Full (potentially pretty-printed) mods_data_json for debugging:"
          echo "$mods_data_json"
        env:
          # This step doesn't require PAT_TOKEN, GITHUB_TOKEN is sufficient for repo checkout
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-index:
    needs: detect-changes
    if: needs.detect-changes.outputs.mods_json != '[]'
    runs-on: ubuntu-latest
    environment: production-main # CRITICAL: Enforce PAT_TOKEN usage via environment
    env:
      TARGET_REPO: "skyline69/balatro-mod-index"
      TARGET_BRANCH: "main"
      FORK_OWNER: "gfreitash"
      AUTHOR: "riosodu"
    strategy:
      matrix:
        mod: ${{ fromJson(needs.detect-changes.outputs.mods_json) }}
    steps:
      - name: Checkout repository (gfreitash/balatro-mods)
        uses: actions/checkout@v4

      - name: Verify mod and index files
        id: verify_files
        run: |
          MOD_DIR_NAME="${{ matrix.mod.dirName }}"
          MOD_VERSION="${{ matrix.mod.version }}"
          echo "üîç Verifying mod structure for directory: $MOD_DIR_NAME (Title: ${{ matrix.mod.titleName }})"

          if [ ! -d "$MOD_DIR_NAME" ]; then
            echo "‚ùå Error: Mod folder '$MOD_DIR_NAME' does not exist in ${{ github.repository }}"
            exit 1
          fi
          if [ ! -f "$MOD_DIR_NAME/index.meta.json" ]; then
            echo "‚ùå Error: index.meta.json not found in $MOD_DIR_NAME in ${{ github.repository }}"
            exit 1
          fi
          if [ ! -f "$MOD_DIR_NAME/README.md" ]; then
            echo "‚ùå Error: README.md not found in $MOD_DIR_NAME in ${{ github.repository }}"
            exit 1
          fi
          # Check for manifest.json for the description part
          if [ ! -f "$MOD_DIR_NAME/manifest.json" ]; then
            echo "‚ö†Ô∏è Warning: manifest.json not found in $MOD_DIR_NAME in ${{ github.repository }}. PR description will indicate this."
          fi
          echo "‚úÖ All required files found for $MOD_DIR_NAME"

          # --- index.meta.json Validation ---
          INDEX_META_PATH="$MOD_DIR_NAME/index.meta.json"
          INDEX_META_CONTENT=$(cat "$INDEX_META_PATH")

          # Strict XOR check: 'version' OR 'automatic-version-check', but not both, and one must be present.
          if ! echo "$INDEX_META_CONTENT" | jq -e '(has("version") and (has("automatic-version-check") | not)) or ((has("version") | not) and has("automatic-version-check"))' >/dev/null; then
            echo "‚ùå Error: ${INDEX_META_PATH} must have exactly one of 'version' or 'automatic-version-check' fields."
            exit 1
          fi

          IS_AUTO_VERSION_CHECK="false"
          # If 'version' field exists (and 'automatic-version-check' does not, due to XOR)
          if echo "$INDEX_META_CONTENT" | jq -e 'has("version")' >/dev/null; then
            IS_AUTO_VERSION_CHECK="false"
            echo "IS_AUTO_VERSION_CHECK=false" >> "$GITHUB_OUTPUT"
          # If 'automatic-version-check' field exists (and 'version' does not, due to XOR)
          elif echo "$INDEX_META_CONTENT" | jq -e 'has("automatic-version-check")' >/dev/null; then
            IS_AUTO_VERSION_CHECK="true"
            echo "IS_AUTO_VERSION_CHECK=true" >> "$GITHUB_OUTPUT"
          fi

          # Validate version consistency if 'version' field is present
          if [ "$IS_AUTO_VERSION_CHECK" = "false" ]; then
            META_VERSION=$(echo "$INDEX_META_CONTENT" | jq -r '.version')
            if [ "$META_VERSION" != "$MOD_VERSION" ]; then
              echo "‚ùå Error: Version mismatch in ${INDEX_META_PATH}. Expected '$MOD_VERSION' but found '$META_VERSION'. Did you forget to run sync-versions.sh?"
              exit 1
            fi
          fi

          # Validate downloadURL format
          DOWNLOAD_URL=$(echo "$INDEX_META_CONTENT" | jq -r '.downloadURL')
          EXPECTED_REPO_PATH="https://github.com/${{ github.repository }}/releases/download"

          # CRITICAL CHANGE: Download URL validation depends on IS_AUTO_VERSION_CHECK
          if [ "$IS_AUTO_VERSION_CHECK" = "true" ]; then
            # If automatic-version-check is true, expect downloadURL to use the MOD_NAME__latest tag
            EXPECTED_DOWNLOAD_URL_PATTERN="${EXPECTED_REPO_PATH}/${MOD_DIR_NAME}__latest/${MOD_DIR_NAME}.zip"
            if [[ "$DOWNLOAD_URL" != "$EXPECTED_DOWNLOAD_URL_PATTERN" ]]; then
              echo "‚ùå Error: Download URL in ${INDEX_META_PATH} is not in the proper format for 'automatic-version-check'. It should be '${EXPECTED_DOWNLOAD_URL_PATTERN}'."
              exit 1
            fi
          else
            # If automatic-version-check is false, expect downloadURL to use the specific versioned tag
            EXPECTED_DOWNLOAD_URL_PATTERN="${EXPECTED_REPO_PATH}/${{ matrix.mod.tagName }}/${MOD_DIR_NAME}.zip"
            if [[ "$DOWNLOAD_URL" != "$EXPECTED_DOWNLOAD_URL_PATTERN" ]]; then
              echo "‚ùå Error: Download URL in ${INDEX_META_PATH} is not in the proper format for explicit versioning. It should be '${EXPECTED_DOWNLOAD_URL_PATTERN}'."
              exit 1
            fi
          fi
          echo "‚úÖ index.meta.json validated successfully."

      - name: Check if mod exists in index
        id: check_exists
        run: |
          MOD_DIR_NAME="${{ matrix.mod.dirName }}"
          echo "üîç Checking if mod ${{ env.AUTHOR }}@$MOD_DIR_NAME exists in index..."
          echo "üì• Cloning target repository to check existing mods..."
          # Clone with limited depth for efficiency if only checking for directory existence
          # Use the default GITHUB_TOKEN for cloning public repo
          git clone --depth 1 "https://github.com/${{ env.TARGET_REPO }}.git" temp-index || exit 1

          if [ -d "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Mod ${{ env.AUTHOR }}@${MOD_DIR_NAME} already exists in index"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "üÜï Mod ${{ env.AUTHOR }}@${MOD_DIR_NAME} is new to index"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Use default GITHUB_TOKEN for cloning public repo

      - name: Check for changes that matter
        id: check_changes
        run: |
          MOD_DIR_NAME="${{ matrix.mod.dirName }}"
          MOD_VERSION="${{ matrix.mod.version }}"
          MOD_TAG_NAME="${{ matrix.mod.tagName }}"
          IS_AUTO_VERSION_CHECK="${{ steps.verify_files.outputs.IS_AUTO_VERSION_CHECK }}"

          echo "üîç Analyzing changes for $MOD_DIR_NAME (v$MOD_VERSION) to determine if PR is needed..."

          mkdir -p "temp-current/${{ env.AUTHOR }}@${MOD_DIR_NAME}"

          # CRITICAL CHANGE: Conditionally add 'version' to the meta.json being prepared for comparison
          PREPARE_META_COMMAND=""
          if [ "$IS_AUTO_VERSION_CHECK" = "false" ]; then
            # If not auto-version-check, we need the version field and the specific versioned downloadURL
            PREPARE_META_COMMAND="jq --arg url \"https://github.com/${{ github.repository }}/releases/download/${MOD_TAG_NAME}/${MOD_DIR_NAME}.zip\" --arg folder \"$MOD_DIR_NAME\" --arg version \"$MOD_VERSION\" '. + {downloadURL: \$url, folderName: \$folder, version: \$version}'"
          else
            # If auto-version-check, we specifically want to REMOVE the version field from the generated meta.
            # The downloadURL for auto-version-check mods in the index *should* point to the permanent 'latest' asset.
            PREPARE_META_COMMAND="jq --arg url \"https://github.com/${{ github.repository }}/releases/download/${MOD_DIR_NAME}__latest/${MOD_DIR_NAME}.zip\" --arg folder \"$MOD_DIR_NAME\" 'del(.version) | . + {downloadURL: \$url, folderName: \$folder}'"
          fi

          eval "$PREPARE_META_COMMAND" "$MOD_DIR_NAME/index.meta.json" > "temp-current/${{ env.AUTHOR }}@${MOD_DIR_NAME}/meta.json"

          cp "$MOD_DIR_NAME/README.md" "temp-current/${{ env.AUTHOR }}@${MOD_DIR_NAME}/description.md"

          if [ -f "$MOD_DIR_NAME/index.thumbnail.jpg" ]; then
            cp "$MOD_DIR_NAME/index.thumbnail.jpg" "temp-current/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg"
          fi

          if [ "${{ steps.check_exists.outputs.exists }}" = "true" ]; then
            echo "üìä Comparing with existing mod in index..."
            VERSION_ONLY_CHANGE=true

            EXISTING_META_JSON_PATH="temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/meta.json"
            EXISTING_META_TRANSFORMED=""

            # Transform existing meta for comparison, removing 'version' if IS_AUTO_VERSION_CHECK is true
            if [ "$IS_AUTO_VERSION_CHECK" = "true" ]; then
              EXISTING_META_TRANSFORMED=$(jq 'del(.version)' "$EXISTING_META_JSON_PATH" 2>/dev/null || echo "{}")
            else
              EXISTING_META_TRANSFORMED=$(cat "$EXISTING_META_JSON_PATH" 2>/dev/null || echo "{}")
            fi

            # Now compare the current prepared meta.json with the transformed existing one (excluding version field from both for comparison)
            if ! jq 'del(.version)' "temp-current/${{ env.AUTHOR }}@${MOD_DIR_NAME}/meta.json" | \
                 diff -q - <(echo "$EXISTING_META_TRANSFORMED") >/dev/null 2>&1; then
              echo "üìù Meta.json has non-version changes"
              VERSION_ONLY_CHANGE=false
            fi

            if ! diff -q "$MOD_DIR_NAME/README.md" "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/description.md" >/dev/null 2>&1; then
              echo "üìù Description has changes"
              VERSION_ONLY_CHANGE=false
            fi

            if [ -f "$MOD_DIR_NAME/index.thumbnail.jpg" ] && [ -f "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg" ]; then
              if ! diff -q "$MOD_DIR_NAME/index.thumbnail.jpg" "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg" >/dev/null 2>&1; then
                echo "üñºÔ∏è Thumbnail has changes"
                VERSION_ONLY_CHANGE=false
              fi
            elif [ -f "$MOD_DIR_NAME/index.thumbnail.jpg" ] && [ ! -f "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg" ]; then
              echo "üñºÔ∏è New thumbnail added"
              VERSION_ONLY_CHANGE=false
            elif [ ! -f "$MOD_DIR_NAME/index.thumbnail.jpg" ] && [ -f "temp-index/mods/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg" ]; then
              echo "üñºÔ∏è Thumbnail removed"
              VERSION_ONLY_CHANGE=false
            fi

            if [ "$VERSION_ONLY_CHANGE" = "true" ]; then
              echo "‚ÑπÔ∏è Only version changed for $MOD_DIR_NAME - mod index will auto-update via automatic-version-check or skip PR"
              echo "version_only_change=true" >> "$GITHUB_OUTPUT"
            else
              echo "üìù Meaningful changes detected for $MOD_DIR_NAME beyond version"
              echo "version_only_change=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "üÜï New mod ($MOD_DIR_NAME) - will create PR"
            echo "version_only_change=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare submission files
        run: |
          MOD_DIR_NAME="${{ matrix.mod.dirName }}"
          MOD_VERSION="${{ matrix.mod.version }}"
          MOD_TAG_NAME="${{ matrix.mod.tagName }}"
          IS_AUTO_VERSION_CHECK="${{ steps.verify_files.outputs.IS_AUTO_VERSION_CHECK }}"

          echo "üìÅ Preparing submission files for $MOD_DIR_NAME (v$MOD_VERSION)..."

          mkdir -p "submission/${{ env.AUTHOR }}@${MOD_DIR_NAME}"

          # CRITICAL CHANGE: Conditionally add 'version' field and set 'downloadURL' based on IS_AUTO_VERSION_CHECK
          if [ "$IS_AUTO_VERSION_CHECK" = "false" ]; then
            # Add version field and the specific downloadURL based on the release tag
            jq --arg url "https://github.com/${{ github.repository }}/releases/download/${MOD_TAG_NAME}/${MOD_DIR_NAME}.zip" \
               --arg folder "$MOD_DIR_NAME" \
               --arg version "$MOD_VERSION" \
               '. + {downloadURL: \$url, folderName: \$folder, version: \$version}' \
               "$MOD_DIR_NAME/index.meta.json" > "submission/${{ env.AUTHOR }}@${MOD_DIR_NAME}/meta.json"
          else
            # If automatic-version-check is true, DO NOT add the 'version' field.
            # The downloadURL should point to the generic 'latest' asset.
            jq --arg url "https://github.com/${{ github.repository }}/releases/download/${MOD_DIR_NAME}__latest/${MOD_DIR_NAME}.zip" \
               --arg folder "$MOD_DIR_NAME" \
               'del(.version) | . + {downloadURL: \$url, folderName: \$folder}' \
               "$MOD_DIR_NAME/index.meta.json" > "submission/${{ env.AUTHOR }}@${MOD_DIR_NAME}/meta.json"
          fi

          cp "$MOD_DIR_NAME/README.md" "submission/${{ env.AUTHOR }}@${MOD_DIR_NAME}/description.md"

          if [ -f "$MOD_DIR_NAME/index.thumbnail.jpg" ]; then
            echo "üñºÔ∏è Copying thumbnail image for $MOD_DIR_NAME..."
            cp "$MOD_DIR_NAME/index.thumbnail.jpg" "submission/${{ env.AUTHOR }}@${MOD_DIR_NAME}/thumbnail.jpg"
          else
            echo "‚ÑπÔ∏è No thumbnail found for $MOD_DIR_NAME, skipping..."
          fi
          echo "‚úÖ Submission files prepared successfully for $MOD_DIR_NAME"

      - name: Fork and submit to Balatro Mod Index
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          MOD_DIR_NAME: ${{ matrix.mod.dirName }}
          MOD_TITLE_NAME: ${{ matrix.mod.titleName }}
          MOD_VERSION: ${{ matrix.mod.version }}
          IS_UPDATE: ${{ steps.check_exists.outputs.exists }}
          FORCE_UPDATE: ${{ github.event.inputs.force_update }}
          VERSION_ONLY_CHANGE: ${{ steps.check_changes.outputs.version_only_change }}
          OPEN_PR_ON_VERSION_CHANGE_ONLY: ${{ steps.verify_files.outputs.IS_AUTO_VERSION_CHECK }} # This is the boolean output from verify_files for automatic-version-check
        run: |
          CURRENT_MOD_DIR="${{ env.MOD_DIR_NAME }}"
          CURRENT_MOD_TITLE="${{ env.MOD_TITLE_NAME }}" # Title from index.meta.json
          CURRENT_MOD_VERSION="${{ env.MOD_VERSION }}" # Version from matrix.mod

          # Attempt to read description from the mod's manifest.json in the source repo (gfreitash/balatro-mods)
          # The workflow is running in a checkout of gfreitash/balatro-mods
          MANIFEST_PATH="${CURRENT_MOD_DIR}/manifest.json"
          MOD_MANIFEST_DESCRIPTION_LINE=""

          if [ -f "$MANIFEST_PATH" ]; then
            DESCRIPTION_FROM_MANIFEST=$(jq -r '.description' "$MANIFEST_PATH" 2>/dev/null)
            if [ -n "$DESCRIPTION_FROM_MANIFEST" ] && [ "$DESCRIPTION_FROM_MANIFEST" != "null" ]; then
              # Basic handling for multiline in PR body - ensure it's treated as a single paragraph or handle newlines carefully
              # For simplicity, we'll let it flow as is. GitHub Markdown handles newlines in variables well within multiline strings.
              MOD_MANIFEST_DESCRIPTION_LINE="**Description:** $DESCRIPTION_FROM_MANIFEST"
            else
              MOD_MANIFEST_DESCRIPTION_LINE="**Description:** Not available or empty in ${MANIFEST_PATH}."
            fi
          else
            MOD_MANIFEST_DESCRIPTION_LINE="**Description:** ${MANIFEST_PATH} not found in source repository."
          fi

          # Check if we should skip PR creation
          # Skip if:
          # 1. Only version changed AND
          # 2. FORCE_UPDATE is not true AND
          # 3. OPEN_PR_ON_VERSION_CHANGE_ONLY is false (meaning version field IS present in index.meta.json)
          #
          # If OPEN_PR_ON_VERSION_CHANGE_ONLY is TRUE, it means the mod uses `automatic-version-check`
          # In this case, we SHOULD always create a PR if `VERSION_ONLY_CHANGE` is true
          # (as the index relies on the PR for version bumps for `automatic-version-check` mods).
          # The logic `OPEN_PR_ON_VERSION_CHANGE_ONLY = false` was originally for mods with `version` field
          # that the index auto-updates. Now, we want to create a PR if it's an update, regardless
          # if it's an automatic-version-check type, *unless* force_update is explicitly off and
          # no meaningful changes beyond what the auto-updater would handle were detected.
          # The fix here means: if it's a version-only change for a non-auto-version-checked mod AND no force update, skip.
          # For auto-version-checked mods, we ALWAYS create a PR on update, as the version bump *is* a meaningful change for the index.
          if [ "$VERSION_ONLY_CHANGE" = "true" ] && [ "$FORCE_UPDATE" != "true" ] && [ "$OPEN_PR_ON_VERSION_CHANGE_ONLY" = "false" ]; then
            echo "‚ÑπÔ∏è Skipping PR for $CURRENT_MOD_DIR - only version changed and this mod type does NOT require PR for version updates."
            echo "## ‚ÑπÔ∏è PR Skipped - Auto-Update (Implicit)" >> "$GITHUB_STEP_SUMMARY"
            echo "**Mod Directory:** $CURRENT_MOD_DIR (Title: $CURRENT_MOD_TITLE)" >> "$GITHUB_STEP_SUMMARY"
            echo "**Reason:** Only version changed - typically handled automatically by mod index for this type" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "üöÄ Starting fork and submission process for $CURRENT_MOD_DIR..."
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          git config --global url."https://$GITHUB_TOKEN@github.com/".insteadOf "https://github.com/"

          TARGET_REPO_NAME=$(echo "${{ env.TARGET_REPO }}" | cut -d'/' -f2)

          echo "üç¥ Forking ${{ env.TARGET_REPO }} to ${{ env.FORK_OWNER }}/$TARGET_REPO_NAME"
          if gh repo view "${{ env.FORK_OWNER }}/$TARGET_REPO_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Fork already exists"
          else
            echo "üîÑ Creating fork..."
            gh repo fork "${{ env.TARGET_REPO }}" --clone=false
            echo "‚è≥ Waiting for fork..." && sleep 10
          fi

          echo "üì• Cloning fork..."
          gh repo clone "${{ env.FORK_OWNER }}/$TARGET_REPO_NAME" mod-index-fork
          cd mod-index-fork

          echo "üîÑ Setting up upstream remote..."
          git remote add upstream "https://github.com/${{ env.TARGET_REPO }}.git" 2>/dev/null || true
          git fetch upstream

          echo "üîÑ Syncing with upstream..."
          git checkout ${{ env.TARGET_BRANCH }} 2>/dev/null || git checkout -b ${{ env.TARGET_BRANCH }} upstream/${{ env.TARGET_BRANCH }}
          git reset --hard upstream/${{ env.TARGET_BRANCH }}
          git remote set-url origin "https://$GITHUB_TOKEN@github.com/${{ env.FORK_OWNER }}/$TARGET_REPO_NAME.git"
          echo "üì§ Syncing fork with upstream..."
          git push origin ${{ env.TARGET_BRANCH }} --force-with-lease

          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          PR_MOD_IDENTIFIER="${{ env.AUTHOR }}@${CURRENT_MOD_DIR}"

          if [ "$IS_UPDATE" = "true" ]; then
            BRANCH_NAME="update-${CURRENT_MOD_DIR}-${TIMESTAMP}"
            PR_TITLE="Update ${PR_MOD_IDENTIFIER} mod to v${CURRENT_MOD_VERSION}"
            PR_BODY="Automated update of the mod '$CURRENT_MOD_TITLE' (directory: $CURRENT_MOD_DIR) to version \`v${CURRENT_MOD_VERSION}\`.

          **Mod:** \`${PR_MOD_IDENTIFIER}\`
          ${MOD_MANIFEST_DESCRIPTION_LINE}

          **Source Files (in ${GITHUB_REPOSITORY}):** ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/tree/main/${CURRENT_MOD_DIR}
          **Triggering Commit (in ${GITHUB_REPOSITORY}):** [${GITHUB_SHA:0:7}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA})

          ---
          **Note:** This PR was created automatically. Review comments and feedback are welcome."
            echo "üîÑ Preparing update for existing mod $CURRENT_MOD_DIR..."
          else
            BRANCH_NAME="add-${CURRENT_MOD_DIR}-${TIMESTAMP}"
            PR_TITLE="Add ${PR_MOD_IDENTIFIER} mod v${CURRENT_MOD_VERSION}"
            PR_BODY="New mod submission: '$CURRENT_MOD_TITLE' (directory: $CURRENT_MOD_DIR) version \`v${CURRENT_MOD_VERSION}\`.

          **Mod Details:**
          - Author: ${{ env.AUTHOR }}
          - Name: $CURRENT_MOD_TITLE (Directory: $CURRENT_MOD_DIR)

          **Mod:** \`${PR_MOD_IDENTIFIER}\`
          ${MOD_MANIFEST_DESCRIPTION_LINE}

          **Source Files (in ${GITHUB_REPOSITORY}):** ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/tree/main/${CURRENT_MOD_DIR}
          **Triggering Commit (in ${GITHUB_REPOSITORY}):** [${GITHUB_SHA:0:7}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA})

          ---
          **Note:** This PR was created automatically. Review comments and feedback are welcome."
            echo "üÜï Preparing submission for new mod $CURRENT_MOD_DIR..."
          fi

          echo "üåø Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          echo "üìÅ Copying submission files..."
          # Ensure the mods directory exists within the cloned index repo
          mkdir -p mods/"${{ env.AUTHOR }}@${MOD_DIR_NAME}"
          # Copy content directly into the specific mod subdirectory
          cp -r ../submission/"${{ env.AUTHOR }}@${MOD_DIR_NAME}"/* mods/"${{ env.AUTHOR }}@${MOD_DIR_NAME}"/

          echo "üìã Files in submission:" && find mods/"${{ env.AUTHOR }}@${MOD_DIR_NAME}" -type f | head -20

          echo "üîç Checking for existing open PRs for $PR_MOD_IDENTIFIER..."
          export TEMP_GITHUB_TOKEN="$GITHUB_TOKEN"
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}" # Use default GITHUB_TOKEN for PR listing

          EXISTING_PRS=$(gh pr list \
            --repo "${{ env.TARGET_REPO }}" \
            --state open \
            --search "in:title ${PR_MOD_IDENTIFIER}" \
            --json number,title \
            --jq '.[] | select(.title | contains("'${PR_MOD_IDENTIFIER}'"))')

          export GITHUB_TOKEN="$TEMP_GITHUB_TOKEN" # Revert to PAT_TOKEN for push/PR creation

          if [ -n "$EXISTING_PRS" ] && [ "$FORCE_UPDATE" != "true" ]; then
            echo "‚ö†Ô∏è Found existing open PR(s) for $PR_MOD_IDENTIFIER:"
            echo "$EXISTING_PRS" | jq -r '"- #\(.number): \(.title)"'
            echo "üö´ Skipping PR creation."
            echo "## ‚ö†Ô∏è PR Skipped - Existing PR" >> "$GITHUB_STEP_SUMMARY"
            echo "**Mod Directory:** $CURRENT_MOD_DIR (Title: $CURRENT_MOD_TITLE)" >> "$GITHUB_STEP_SUMMARY"
            echo "**Reason:** Existing open PR found for \`${PR_MOD_IDENTIFIER}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "$EXISTING_PRS" | jq -r '"- #\(.number): \(.title)"' >> "$GITHUB_STEP_SUMMARY"
            exit 0
          elif [ -n "$EXISTING_PRS" ] && [ "$FORCE_UPDATE" = "true" ]; then
            echo "üîß Found existing open PR(s) but force update is enabled. Proceeding..."
          fi

          git add .
          if git diff --cached --quiet; then
            if [ "$FORCE_UPDATE" != "true" ]; then
              echo "‚ÑπÔ∏è No changes detected for $CURRENT_MOD_DIR, skipping PR creation"
              exit 0
            else
              echo "üîß Force update requested for $CURRENT_MOD_DIR, creating empty commit"
              git commit --allow-empty -m "$PR_TITLE (forced update)"
            fi
          else
            echo "üíæ Committing changes for $CURRENT_MOD_DIR..."
            git commit -m "$PR_TITLE"
          fi

          echo "üì§ Pushing to origin/$BRANCH_NAME"
          git push origin "$BRANCH_NAME"

          echo "üéØ Creating PR to ${{ env.TARGET_REPO }}"
          PR_URL=$(gh pr create \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --base ${{ env.TARGET_BRANCH }} \
            --head "${{ env.FORK_OWNER }}:$BRANCH_NAME" \
            --repo "${{ env.TARGET_REPO }}")

          echo "‚úÖ PR created successfully for $CURRENT_MOD_DIR: $PR_URL"
          echo "## üéâ Pull Request Created" >> "$GITHUB_STEP_SUMMARY"
          echo "**Mod Directory:** $CURRENT_MOD_DIR (Title: $CURRENT_MOD_TITLE)" >> "$GITHUB_STEP_SUMMARY"
          echo "**PR:** [$PR_TITLE]($PR_URL)" >> "$GITHUB_STEP_SUMMARY"
