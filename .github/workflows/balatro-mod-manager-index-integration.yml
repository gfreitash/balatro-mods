name: Update Balatro Mod Index

on:
  workflow_dispatch:
    inputs:
      mod_name:
        description: "Mod name to update (e.g., black-seal)"
        required: true
        type: string
      force_update:
        description: "Force update even if no changes detected"
        required: false
        type: boolean
        default: false

  # Auto-trigger when index files change
  push:
    paths:
      - "*/index.meta.json"
      - "*/index.description.md"
      - "*/index.thumbnail.jpg"
    branches:
      - main

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed_mods: ${{ steps.changes.outputs.mods }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed mods
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger
            echo "mods=[\"${{ github.event.inputs.mod_name }}\"]" >> $GITHUB_OUTPUT
          else
            # Auto-trigger: detect which mods had index files changed
            changed_files=$(git diff --name-only HEAD~1 HEAD)
            mods=()

            for file in $changed_files; do
              if [[ $file =~ ^([^/]+)/index\.(meta\.json|description\.md|thumbnail\.jpg)$ ]]; then
                mod_name="${BASH_REMATCH[1]}"
                if [[ ! " ${mods[@]} " =~ " ${mod_name} " ]]; then
                  mods+=("$mod_name")
                fi
              fi
            done

            # Convert to JSON array
            printf -v joined '"%s",' "${mods[@]}"
            echo "mods=[${joined%,}]" >> $GITHUB_OUTPUT
          fi

  update-index:
    needs: detect-changes
    if: needs.detect-changes.outputs.changed_mods != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mod_name: ${{ fromJson(needs.detect-changes.outputs.changed_mods) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify mod and index files
        run: |
          MOD_NAME="${{ matrix.mod_name }}"
          if [ ! -d "$MOD_NAME" ]; then
            echo "Error: Mod folder '$MOD_NAME' does not exist"
            exit 1
          fi
          if [ ! -f "$MOD_NAME/index.meta.json" ]; then
            echo "Error: index.meta.json not found in $MOD_NAME"
            exit 1
          fi
          if [ ! -f "$MOD_NAME/index.description.md" ]; then
            echo "Error: index.description.md not found in $MOD_NAME"
            exit 1
          fi

      - name: Get latest version for mod
        id: version
        run: |
          MOD_NAME="${{ matrix.mod_name }}"
          # Get the latest version from releases
          LATEST_VERSION=$(gh release list --repo ${{ github.repository }} --limit 100 | \
            grep "^${MOD_NAME}__v" | head -1 | awk '{print $1}' | sed "s/${MOD_NAME}__v//")

          if [ -z "$LATEST_VERSION" ]; then
            echo "Warning: No releases found for $MOD_NAME, using 0.0.0"
            LATEST_VERSION="0.0.0"
          fi

          echo "version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Latest version for $MOD_NAME: $LATEST_VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if mod exists in index
        id: check_exists
        run: |
          MOD_NAME="${{ matrix.mod_name }}"
          AUTHOR="riosodu"

          # Clone the mod index to check if mod already exists
          gh repo clone skyline69/balatro-mod-index temp-index || exit 1

          if [ -d "temp-index/mods/${AUTHOR}@${MOD_NAME}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Mod ${AUTHOR}@${MOD_NAME} already exists in index"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Mod ${AUTHOR}@${MOD_NAME} is new to index"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload submission files as artifact
        uses: actions/upload-artifact@v4
        with:
          name: mod-index-submission-${{ matrix.mod_name }}
          path: submission/


      - name: Fork and submit to Balatro Mod Index
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          MOD_NAME: ${{ matrix.mod_name }}
          IS_UPDATE: ${{ steps.check_exists.outputs.exists }}
          FORCE_UPDATE: ${{ github.event.inputs.force_update }}
          TARGET_REPO: "ghfreitas-oss/test-balatro-mod-index"
          TARGET_BRANCH: "master"
          FORK_OWNER: "gfreitash"
        run: |
          # Configure git with your details
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

          # Configure git to use the PAT for GitHub authentication
          git config --global url."https://$GITHUB_TOKEN@github.com/".insteadOf "https://github.com/"

          TARGET_REPO_NAME=$(echo "$TARGET_REPO" | cut -d'/' -f2)
          TARGET_REPO_OWNER=$(echo "$TARGET_REPO" | cut -d'/' -f1)

          echo "🍴 Forking $TARGET_REPO to $FORK_OWNER/$TARGET_REPO_NAME"

          # Check if fork already exists
          if gh repo view "$FORK_OWNER/$TARGET_REPO_NAME" >/dev/null 2>&1; then
            echo "✅ Fork already exists"
          else
            echo "🔄 Creating fork..."
            FORK_URL=$(gh repo fork "$TARGET_REPO" --clone=false)
            echo "✅ Fork created: $FORK_URL"

            # Wait for fork to be fully available
            echo "⏳ Waiting for fork to be fully available..."
            sleep 10
          fi

          # Clone the fork
          echo "📥 Cloning fork..."
          gh repo clone "$FORK_OWNER/$TARGET_REPO_NAME" mod-index-fork
          cd mod-index-fork

          # Set up upstream remote with authentication
          echo "🔄 Setting up upstream remote..."
          git remote add upstream "https://$GITHUB_TOKEN@github.com/$TARGET_REPO.git" 2>/dev/null || true
          git fetch upstream

          # Ensure we're on the target branch and synced
          echo "🔄 Syncing with upstream..."
          git checkout $TARGET_BRANCH 2>/dev/null || git checkout -b $TARGET_BRANCH upstream/$TARGET_BRANCH
          git reset --hard upstream/$TARGET_BRANCH

          # Configure the origin remote to use the token (important!)
          git remote set-url origin "https://$GITHUB_TOKEN@github.com/$FORK_OWNER/$TARGET_REPO_NAME.git"

          # Push the synced branch to your fork
          echo "📤 Syncing fork with upstream..."
          git push origin $TARGET_BRANCH --force-with-lease

          # Create unique branch name with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          if [ "$IS_UPDATE" = "true" ]; then
            BRANCH_NAME="update-${MOD_NAME}-${TIMESTAMP}"
            PR_TITLE="Update riosodu@${MOD_NAME} mod"
            PR_BODY="🔄 **Automated update** of the ${MOD_NAME} mod

          **Changes:**
          - Updated mod metadata and description
          - Refreshed from source repository
          - Automated via GitHub Actions

          **Mod:** \`riosodu@${MOD_NAME}\`
          **Source:** ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}
          **Commit:** ${GITHUB_SHA:0:7}"
          else
            BRANCH_NAME="add-${MOD_NAME}-${TIMESTAMP}"
            PR_TITLE="Add riosodu@${MOD_NAME} mod"
            PR_BODY="✨ **New mod submission** for ${MOD_NAME}

          **Mod Details:**
          - Author: riosodu
          - Name: ${MOD_NAME}
          - Automated submission from mono-repository

          **Source:** ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}
          **Commit:** ${GITHUB_SHA:0:7}"
          fi

          # Create and switch to feature branch
          echo "🌿 Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          # Copy submission files
          echo "📁 Copying submission files..."
          mkdir -p mods
          cp -r ../submission/* mods/

          # Show what was copied for debugging
          echo "📋 Files in submission:"
          find mods -type f | head -20

          # Stage changes
          git add .

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            if [ "$FORCE_UPDATE" != "true" ]; then
              echo "ℹ️ No changes detected, skipping PR creation"
              exit 0
            else
              echo "🔧 Force update requested, creating empty commit"
              git commit --allow-empty -m "$PR_TITLE (forced update)"
            fi
          else
            echo "💾 Committing changes..."
            git commit -m "$PR_TITLE"
          fi

          # Push the feature branch
          echo "📤 Pushing to origin/$BRANCH_NAME"
          git push origin "$BRANCH_NAME"

          # Create PR to the original repository
          echo "🎯 Creating PR to $TARGET_REPO"
          PR_URL=$(gh pr create \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --base $TARGET_BRANCH \
            --head "$FORK_OWNER:$BRANCH_NAME" \
            --repo "$TARGET_REPO")

          echo "✅ PR created successfully: $PR_URL"

          # Add PR URL to job summary
          echo "## 🎉 Pull Request Created" >> $GITHUB_STEP_SUMMARY
          echo "**Mod:** $MOD_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** [$PR_TITLE]($PR_URL)" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
